
# Redux

## React의 짝꿍
리액트에서 대부분 자식컴포넌트는 **부모컴포넌트를 중간역할**로 두고 서로 소통을 한다.<br>
즉, 자식컴포넌트의 변경된 상태를 업데이트하고 다른 자식 컴포넌트에 내려주는 과정을<br>
부모컴포넌트가 하기 때문에 비교적 관리하기에 쉬운 편이다.<br><br>
하지만 우리가 만들고 사용하는 앱은 점점 규모가 커지고 복잡해진다.<br>
그에 따라 컴포넌트의 수가 많아지거나 깊어질 수록, 관련된 데이터와 함수들도 늘어난다.<br>
그럴수록 부모컴포넌트의 길이는 감당하기 힘들정도로 길어지고 관리하기 어려워 질 것이다.<br>
(물론 컴포넌트들끼리 직접소통하는 등 부모컴포넌트를 거치지 않는 방법도 있지만 추천하지않는다.)<br><br>
이런 이유로 우리는 Redux를 사용한다.<br><br>
><br>물론 순수리액트만 이용해서 개발 가능하다! 그러나 사용하면 편리하고 유지보수가 쉬워지는 장점이 있다!<br>
>또한, 꼭 React에서만 사용해야하는 것은 아니지만 React에 잘 어울리는 것은 분명하다!<br><br>

## 그래서 Redux가 뭐지?

### FLUX architecture 그리고 Redux.

FLUX디자인은 action이 발생하면 Dispatcher가 이를 받아 Store에 업데이트하고 변동사항은 View에 반영한다.<br>
View에서도 action이 발생되어 Dispatcher로 보낼 수 있지만 이미 다른 action을 처리 중이라면 대기 처리 된다.<br><br>
><br>이 FlUX를 조금 더 편하게 사용하게끔 하는 것이 Redux다<br><br>

## Redux
flux는 다수의 store를 사용하지만<br>
**Redux**는 외부에 하나의 스토어두고 컴포넌트와 스토어 사이에 변경사항을 반영해주는 라이브러리이다!<br>
아무리 깊게 존재하는 컴포넌트라도 직속부모에게 변경사항을 업데이트하고 받아오는 것 처럼 간단해진다<br>
```
"A 컴포넌트 -> 스토어에 변경된 상태 업데이트하고 (Dispatch)
스토어는 -> B컴포넌트로 필요한 상태의 변경사항을 props로 전달 (subscribe)"
```
<br><br>
![Redux01](https://github.com/WonjeongPark/whatIThink/blob/master/IMG/Redux01.png?raw=true)
<br><br>

## Redux 원칙 3가지

Redux를 사용할 때 주의해야 할 3가지 원칙이 있다.<br>

### 1. Single Source of Truth
<br>Flux에서는 다수의 스토어를 사용하는 반면 **Redux는 하나의 스토어를 사용**하는 것을 권장한다.<br>
**하나의 애플리케이션에 속한 모든 상태는 하나의 객체 트리 구조로 하나의 스토어 안에 저장된다.**<br>
개발자의 성향에 따라 다르게 구현가능 하겠지만, 하나의 객체트리만 존재하기 때문에<br>
상태를 바로 저장/불러오기를 하거나, 디버깅을 하거나, 실행취소/다시실행 구현하는 것이 쉽다.<br>
개발도구로 잘 활용하기 위해서는 하나의 스토어를 사용하는 것이 좋다.<br><br>

### 2. State is read-only
<br>**State의 변경은 action 객체에 의해서만 발생한다.**<br>
모든 action은 중첩되는 과정 없이 정해진 순서에 의해 dispatch되어 State에 어떤 변화가 일어나야 하는지 알려 준다.<br>
즉 애플리케이션에서 뷰나 콜백 등으로 state를 직접 변경할 수 없다.<br>
리덕스에서는 데이터의 변화를 감지할 때 재귀적으로 각 단계의 속성을 비교하지 않고 <br>
shallow equlity chech로 간단하고 빠르게<br>
**두 객체의 값**이 동일한지 비교하기 때문에 **불변성**을 유지해야 하기 때문이다.<br><br>

### 3. Changes are made with Pure Functions
<br>State의 변화는 dispatch된 action에 의해서 일어나고 그 action을 받아서 처리하는 것이 reducer함수다.<br>
reducer가 Pure function, 즉 **순수함수로 작성**되어야 액션에 의해 상태가 어떻게 변화하는 지 알 수 있다.<br>
두번째 원칙에서와 마찬가지로 리덕스는 두 객체의 값이 동일한지의 여부로 변화를 감지하기 때문에<br>
리듀서 내부에서 하나의 객체의 속성을 직접 바꾸면(mutate directly) 바뀌기 전과 후는 값만 바뀐 동일한 **객체**이고<br>
리덕스에서는 이를 변경사항이 없다고 생각한다.<br>
즉, 동일한 객체안에서 같은 파라미터값으로 다른 값이 나오는 함수를 사용하여 값이 변경되면<br>
리덕스에서 변화는 감지되지 않기때문에 같은 파라미터에 같은 결과를 리턴하는 순수함수를 사용해야 하는 것이다.<br><br>
왜 굳이 이런 불편을 감수하게 하는 걸까?<br><br>
복잡하고 깊은 비교(deep)를 하게되면 한 객체에 연결된 속성이나 변수를 비교해야하므로<br>
그 만큼 무겁고 비효율적인 비교방법이 사용되어야 하기 때문이다.<br>
따라서 변경 사항이 있을 때마다 새 객체를 만드는 것으로 리덕스는 변화된 상태를 인지하고,<br>
변경 사항이 없다면 이전 객체를 그대로 되돌려 보내 변화가 없는 걸로 인지하는 방법을 리덕스에서 사용하고 있다.<br>

```
1) reducer는 이전상태와 액션을 파라미터값으로 받아<br>
2) 이 값에 의존하여
3) 새로운 상태객체를 생성하여 return한다.<br>
4) 같은 파라미터로 호출된 리듀서는 언제나 같은 값을 반환해야 한다.
5) new Date(), Math.random() 등 결과 값이 항상 같지 않은 작업은 리덕스미들웨어에서 사용해야 한다.<br>
```

## 리덕스 미들웨어

리덕스 미들웨어는 리덕스 기능을 구현하는데 꼭 필요한 기능은 아니지만<br>
개발자의 판단에 따라 비동기 작업(외부데이터 연동)등 유용하게 사용될 수 있다.<br>

### 미들웨어란?
미들웨어는 리덕스만의 기능은 아니다. 위키백과에 따르면 '응용소프트웨어가 운영체제로부터 제공받는 서비스 이외에 <br>
추가적으로 이용할 수 있는 서비스를 제공하는 컴퓨터 소프트웨어' 라고 나와있다.<br>
단일 기능으로 준비되어 어떻게 사용하느냐에 따라 달라지는 광범위 기능 단위라 생각 할 수 있다.<br>
소프트웨어에 한정적인 것은 아니고 서버 쪽 하드웨어 미들웨어로 방화벽이 쓰이는 경우도 있다.<br><br>
리덕스에서 미들웨어는 action과 reducer사이에 위치하고 있다.<br>
action이 dispatch되어 reducer에서 처리하기 전에 정해진 작업들을 수행한다.<br>
Redux DevTool을 이용(불가능 하다면 redux-logger을 사용)할 수도 있고<br>
비동기 작업을 위해 리덕스 미들웨어의 기본적인 방법으로redux-thunk를 사용할 수 있다.<br>
thunk란 특정한 작업을 바로 실행하는 것이 아니라 나중으로 미루기 위해서 함수형태로 감싼 것이다.<br>
몇 초 뒤에 함수가 실행되게 하거나 현재 상태에 따라 실행되지 않게 하기위해 사용한다.<br>
뿐만 아니라 이미 존재하는 손쉽고 도움이 되는 미들웨어들은 여럿 존재한다.<br>
적용과정들은 거의 비슷한 방법으로 많이 검색 가능한 것 같다.<br><br><br>


## 글의 제목에 WhyRedux가 빠진 이유

이 문단을 생각에서 글로 옮기는 이유는 지금보다 더 넓은 식견을 가지게 되었을 때 <br>
잊지말고 다시 생각해 보기 위함이다.<br><br>
미들웨어에 대해 알아보면서 단순히 리덕스에 국한된 기능이 아니라는 것을 알아가면서<br>
리액트를 공부하면서 알게되고 배우는 개념이나 기능들이 꼭 리액트에만 한정적인 것이 아니라<br>
다른 이름으로 혹은 비슷한 흐름으로 프로그래밍 어디에서나 쓰이는 것이라는 걸 한번 더 느끼게 되었고<br><br>
이해하기 쉬웠던 개념과 달리 리덕스를 적용하는 과정이 꽤 번거롭거나 과하게 느껴 질 수도 있겠다고 생각한다.<br>
아직 리덕스에 관한 코드를 작성하거나 개념을 이해하는 것이 완벽하지 않지만,<br>
*조금 더 공부하고나면* 리덕스를 왜 써야하는가, **꼭 써야하는가**에 대해 생각해봐야겠다.<br><br>

`많은 개발 기능을 쓰는 개발자와 적재적소에 유용한 기능을 잘 쓰는 엔지니어`<br>
