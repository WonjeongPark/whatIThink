
# Redux

## React의 짝꿍
리액트에서 대부분 자식컴포넌트는 **부모컴포넌트를 중간역할**로 두고 서로 소통을 한다.<br>
즉, 자식컴포넌트의 변경된 상태를 업데이트하고 다른 자식 컴포넌트에 내려주는 과정을<br>
부모컴포넌트가 하기 때문에 비교적 관리하기에 쉬운 편이다.<br><br>
하지만 우리가 만들고 사용하는 앱은 점점 규모가 커지고 복잡해진다.<br>
그에 따라 컴포넌트의 수가 많아지거나 깊어질 수록, 관련된 데이터와 함수들도 늘어난다.<br>
그럴수록 부모컴포넌트의 길이는 감당하기 힘들정도로 길어지고 관리하기 어려워 질 것이다.<br>
(물론 컴포넌트들끼리 직접소통하는 등 부모컴포넌트를 거치지 않는 방법도 있지만 추천하지않는다.)<br><br>
이런 이유로 우리는 Redux를 사용한다.<br><br>
><br>물론 순수리액트만 이용해서 개발 가능하다! 그러나 사용하면 편리하고 유지보수가 쉬워지는 장점이 있다!<br>
>또한, 꼭 React에서만 사용해야하는 것은 아니지만 React에 잘 어울리는 것은 분명하다!<br><br>

## 그래서 Redux가 뭐지?

### FLUX architecture 그리고 Redux.

FLUX디자인은 action이 발생하면 Dispatcher가 이를 받아 Store에 업데이트하고 변동사항은 View에 반영한다.<br>
View에서도 action이 발생되어 Dispatcher로 보낼 수 있지만 이미 다른 action을 처리 중이라면 대기 처리 된다.<br><br>
><br>이 FlUX를 조금 더 편하게 사용하게끔 하는 것이 Redux다<br><br>

## Redux
flux는 다수의 store를 사용하지만<br>
**Redux**는 외부에 하나의 스토어두고 컴포넌트와 스토어 사이에 변경사항을 반영해주는 라이브러리이다!<br>
아무리 깊게 존재하는 컴포넌트라도 직속부모에게 변경사항을 업데이트하고 받아오는 것 처럼 간단해진다<br>
```
"A 컴포넌트 -> 스토어에 변경된 상태 업데이트하고 (Dispatch)
스토어는 -> B컴포넌트로 필요한 상태의 변경사항을 props로 전달 (subscribe)"
```
<br><br>
![Redux01](https://github.com/WonjeongPark/whatIThink/blob/master/IMG/Redux01.png?raw=true)
<br><br>

## Redux 원칙 3가지

Redux를 사용할 때 주의해야 할 3가지 원칙이 있다.<br>

### 1. Single Source of Truth
<br>Flux에서는 다수의 스토어를 사용하는 반면 **Redux는 하나의 스토어를 사용**하는 것을 권장한다.<br>
**하나의 애플리케이션에 속한 모든 상태는 하나의 객체 트리 구조로 하나의 스토어 안에 저장된다.**<br>
개발자의 성향에 따라 다르게 구현가능 하겠지만, 하나의 객체트리만 존재하기 때문에<br>
상태를 바로 저장/불러오기를 하거나, 디버깅을 하거나, 실행취소/다시실행 구현하는 것이 쉽다.<br>
개발도구로 잘 활용하기 위해서는 하나의 스토어를 사용하는 것이 좋다.<br><br>

### 2. State is read-only
<br>**State의 변경은 action 객체에 의해서만 발생한다.**<br>
모든 action은 중첩되는 과정 없이 정해진 순서에 의해 dispatch되어 State에 어떤 변화가 일어나야 하는지 알려 준다.<br>
즉 애플리케이션에서 뷰나 콜백 등으로 state를 직접 변경할 수 없다.<br>
리덕스에서는 데이터의 변화를 감지할 때 재귀적으로 각 단계의 속성을 비교하지 않고 <br>
간단하고 빠르게 두 객체가 동일한지 비교하기 때문에 (a === b) **불변성**을 유지해야 하기 때문이다.<br><br>

### 3. Changes are made with Pure Functions
<br>State의 변화는 dispatch된 action에 의해서 일어나고 그 action을 받아서 처리하는 것이 reducer함수다.<br>
reducer가 Pure function, 즉 **순수함수로 작성**되어야 액션에 의해 상태가 어떻게 변화하는 지 알 수 있다.<br>
두번째 원칙에서와 마찬가지로 리덕스는 두 객체가 동일한지의 여부를 간단하게 비교하기 때문에<br>
리듀서 내부에서 객체의 속성을 직접 바꾸면 바뀌기 전과 후는 **객체**는 동일하기때문에<br>
리덕스에서는 변경사항이 없다고 생각한다. 그렇게 되면 리듀서는 동작하지 않기때문에 리듀서는 순수함수로 작성되어야 하는 것이다.<br><br>
왜 굳이 이런 불편을 감수하게 하는 걸까?<br><br>
복잡하고 깊은 비교를 하게되면 그 만큼 무겁고 비효율적인 비교방법이 사용되어야 하기 때문이다.<br>
따라서 변경 사항이 있을 때마다 새 객체를 만드는 것으로 새로운 상태를 의미하고,<br>
변경 사항이 없다면 이전 객체를 그대로 되돌려 보내는 방법을 리덕스에서 사용하고 있다.<br>

```
1) reducer는 이전상태와 액션을 파라미터값으로 받아<br>
2) 이 값에 의존하여
3) 새로운 상태객체를 생성하여 return한다.<br>
4) 같은 파라미터로 호출된 리듀서는 언제나 같은 값을 반환해야 한다.
5) new Date(), Math.random() 등 결과 값이 항상 같지 않은 작업은 리덕스미들웨어에서 사용해야 한다.<br>
```

